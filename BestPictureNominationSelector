import random
import tkinter as tk
from tkinter import messagebox
import requests
import webbrowser

# File paths
not_watched_file = 'OscarBestPicturesNotWatched.txt'
watched_file = 'OscarBestPicturesWatched.txt'

#Global Variables
movie_title = None
chosen_line = None
keep_checking_countries = True

other_countries_to_try = ["us", "gb", "ca", "au", "fr", "de", "jp"]
countries_to_try_dictionary = {
    "us": "United States", "gb": "Great Britain", 
    "ca": "Canada", "au": "Australia", 
    "fr": "France", "de": "Germany",
    "jp": "Japan"}

def open_all_movie_links_automatically(services):
    for service in services:
        service_name = service.get("name")
        link = service.get("link")
        webbrowser.open(link) 

def open_all_movie_links_manually(title, services):
    html_lines = [f"<h2>ðŸŽ¬ {title}</h2><ul>"]
    for service in services:
        name = service.get("name", "Unknown Service")
        link = service.get("link", "#")
        html_lines.append(f'<li><a href="{link}" target="_blank">{name}</a></li>')

    html_lines.append("</ul>")
    html_content = "\n".join(html_lines)
    with open("movie_links.html", "w", encoding="utf-8") as f:
        f.write(html_content)
    webbrowser.open("movie_links.html")
    return

def find_possible_streaming_places_function(movie_title, country_code):
    global keep_checking_countries
    keep_checking_countries = True
    url = "https://streaming-availability.p.rapidapi.com/shows/search/title"
    querystring = {
        "title": movie_title,
        #"title": "sorcerer",
        "country": country_code,
        "show_type": "movie"
   }

    headers = {
	"x-rapidapi-key": "7f84ac6968msh506e9250e00e425p122fc7jsn8dccfbd2494f",
	"x-rapidapi-host": "streaming-availability.p.rapidapi.com"
    }

    response = requests.get(url, headers=headers, params=querystring)
    print(response.status_code) 
    if response.status_code != 200:
        print("Error fetching data from the API.")
        messagebox.showerror("Could Not Fetch Data", "Response Status Code == {response.status_code}")
    else:
        data = response.json()
        results = data
        if results:
            first_result = results[0]
            title = first_result["title"]
            services = first_result.get("streamingOptions", {}).get(country_code, {})
            print(f"\nðŸŽ¬ Found: {title}")

            if len(services) == 0:
                messagebox.showwarning("Not Found", f"{movie_title} curently not found in {countries_to_try_dictionary[country_code]} streaming options")
            else:
                #open_all_movie_links_manually(title, services)
                open_all_movie_links_automatically(services)
                keep_checking_countries = False
                    
        else:
           print("No streaming information found for this movie.") 
           messagebox.showwarning("Not Found", f"{movie_title} currently not found in usual streaming options")

def cycle_through_countries_for_movie(movie_title):
    global keep_checking_countries
    for country in other_countries_to_try:
        if keep_checking_countries:
            find_possible_streaming_places_function(movie_title, country)
        else:
            return
        
    messagebox.showwarning("Not Found", f"{movie_title} currently not found in usual streaming options")

def choose_movie(auto_open):
    global movie_title
    global chosen_line
    chosen_line = random.choice(lines)
    print(f"Movie Selected: {chosen_line}")

    movie_info_line = [part for part in chosen_line.split('\t') if part.strip() != '']
    movie_title = movie_info_line[0]
    movie_year = movie_info_line[1]
    movie_producer = movie_info_line[2]

    movie_selected_title.config(text = movie_title)
    movie_selected_year_made.config(text = movie_year)
    movie_selected_producer.config(text = f"Produced By: {movie_producer}")

    print(movie_title) 
    print(movie_year)
    print(movie_producer)

    find_possible_streaming_places_button.pack(pady=20)
    select_and_save_movie_button.pack()

    return chosen_line

def select_and_save_movie():

    message_box_result = messagebox.askyesno("Save Movie", "This will remove movie from Non Watched List")
    if message_box_result:  
        global chosen_line
        if chosen_line in lines:
             lines.remove(chosen_line)
        else:
            print("Error: Selected movie not found in the list.")

        # Overwrite OscarBestPictureNotWatched.txt to write the list without chosen movie
        with open(not_watched_file, 'w') as file:
            for line in lines:
                file.write(line + '\n')

        # Append the chosen movie to OscarBestPicturesWatched.txt
        with open(watched_file, 'a') as file:
            file.write(chosen_line + '\n')

    else:
        print("Canceled.")


def run_movie_selection():
    auto_open = auto_open_var.get()
    choose_movie(auto_open)

# I also want to create menu items that you can see which movies you watched, and maybe all the movies you have not watched
# And maybe even be able to choose those movies from a list so they can be looked up
# And then also, code wise, figure out a way to actually start splitting up this UI from logic into 2 different py files.


def open_popup_window(lines):
    popup = tk.Toplevel(root)
    popup.title("Select an Watched Movie")
    popup.geometry("600x600")

    def on_select(line):
        messagebox.showinfo("Selection", f"You selected: {line}")
        popup.destroy()
        #probably put look up here

    for line in lines:
        btn = tk.Button(popup, text=line, anchor="w", command=lambda i=line: on_select(i))
        btn.pack(fill="x")

def see_watched_list():
    with open(watched_file, 'r') as file:
        lines = [line.strip() for line in file if line.strip()]
    open_popup_window(lines)

def see_unwatched_list():
    with open(not_watched_file, 'r') as file:
        lines = [line.strip() for line in file if line.strip()]
    open_popup_window(lines)

def reset_watched_list():
    message_box_result = messagebox.askyesno("Reset Watched List", "Selecting 'YES' will erase all movies in Watched List?")
    if message_box_result:
         with open(watched_file, 'w') as file:
            pass
            print("Resetting Watched List File")

def reset_unwatched_list():
    print("Open File")

def exit_app():
    root.quit()

with open(not_watched_file, 'r') as file:
    lines = [line.strip() for line in file if line.strip()] 

if not lines:
    print("The source file is empty.")
else:
    root = tk.Tk()
    root.title("Oscar Best Picture Nominated Selector")
    window_width = 1200
    window_height = 800
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()
    x = int((screen_width / 2) - (window_width / 2))
    y = int((screen_height / 2) - (window_height / 2) - 50)
    root.geometry(f"{window_width}x{window_height}+{x}+{y}")
    root.configure(bg="#ffcc99")

    # Create the main menu bar
    menu_bar = tk.Menu(root)
    root.config(menu=menu_bar)

    # ----- File Menu -----
    file_menu = tk.Menu(menu_bar, tearoff=0)  # "tearoff=0" removes the dashed line
    file_menu.add_command(label= "See Watched List", command= lambda:see_watched_list())
    file_menu.add_command(label= "See UnWatched List", command= lambda:see_unwatched_list())
    file_menu.add_separator()
    file_menu.add_command(label="Reset Watched List", command=reset_watched_list)
    file_menu.add_command(label="Reset UnWatched List", command=reset_unwatched_list)
    file_menu.add_separator()
    file_menu.add_command(label="Exit", command=exit_app)
    menu_bar.add_cascade(label="File", menu=file_menu)

    exit_menu = tk.Menu(menu_bar)
    exit_menu.add_command(label="Exit", command=exit_app)
    menu_bar.add_cascade(label="Exit", menu=exit_menu)


    tk.Label(
        root, 
        text="Randomly Find Best Picture Nominated Movie",
        bg="#ffcc99",
        font=("Arial", 20, "bold") 
        ).pack(pady=10)
    
    auto_open_var = tk.BooleanVar()

    button = tk.Button(
        root,
        text="Choose Movie",
        command=run_movie_selection,
        font=("Arial", 20, "bold"),
        width=20,     # number of characters wide
        height=2,     # number of text lines tall
        padx=10,      # internal padding (horizontal)
        pady=10       # internal padding (vertical)
    )
    button.pack(pady=10)

    movie_selected_title = tk.Label(
        root,
        text="Movie Selected : ",
        bg="#ffcc99",
        font=("Arial", 20, "bold"),
        width=100,     
        height=2,     
        padx=10,      
        pady=5 
    )
    movie_selected_title.pack(pady=5)

    movie_selected_year_made = tk.Label(
        root,
        text="Year Made : ",
        bg="#ffcc99",
        font=("Arial", 20, "bold"),
        width=100,     
        height=2,     
        padx=10,      
        pady=5       
    )
    movie_selected_year_made.pack(pady=5)

    movie_selected_producer = tk.Label(
        root,
        text="Produced By : ",
        bg="#ffcc99",
        font=("Arial", 20, "bold"),
        width=100,     
        height=2,     
        padx=10,      
        pady=5    
    )
    movie_selected_producer.pack(pady=5)

    find_possible_streaming_places_button = tk.Button(
        root,
        text="Find Possible Streaming Places",
        command = lambda: cycle_through_countries_for_movie(movie_title),
        font=("Arial", 20, "bold"),
        width=30,     
        height=2,     
        padx=10,      
        pady=10      
    )
    find_possible_streaming_places_button.pack_forget()

    select_and_save_movie_button = tk.Button(
        root,
        text="Choose and Save Movie",
        command = lambda: select_and_save_movie(),
        bg="#03c94f",
        font=("Arial", 20, "bold"),
        width=30,     
        height=2,     
        padx=10,      
        pady=10      
    )
    select_and_save_movie_button.pack_forget()

    root.mainloop()