import random
import tkinter as tk
from tkinter import messagebox
import requests
import webbrowser

# And then also, code wise, figure out a way to actually start splitting up this UI from logic into 2 different py files.
# Also consolidate those popup scrollable window functions (The same set up is currently in 3 different functions.)

# File paths
nominations_full_list_file = 'OscarBestPicturesNominationsFullList.txt'
not_watched_file = 'OscarBestPicturesNotWatched.txt'
watched_file = 'OscarBestPicturesWatched.txt'
service_link_options_file = 'ManualServiceLinkOptionsList.txt'

#Global Variables
movie_title = None
chosen_line = None
keep_checking_countries = True

other_countries_to_try = ["us", "gb", "ca", "au", "fr", "de", "jp"]
countries_to_try_dictionary = {
    "us": "United States", "gb": "Great Britain", 
    "ca": "Canada", "au": "Australia", 
    "fr": "France", "de": "Germany",
    "jp": "Japan"}

def open_all_movie_links_automatically(services):
    for service in services:
        service_name = service.get("name")
        link = service.get("link")
        webbrowser.open(link) 

def open_all_movie_links_manually(title, services):
    streaming_service_pairs = set()
    for service in services:
        serviceIndex = service.get("service", {})
        name = serviceIndex.get("name", "#")
        link = service.get("link", "#")
        streaming_service_pairs.add((name, link))

    open_popup_window_manual(title, streaming_service_pairs)

def find_possible_streaming_places_function(movie_title, country_code, auto_find):
    global keep_checking_countries
    keep_checking_countries = True
    url = "https://streaming-availability.p.rapidapi.com/shows/search/title"
    querystring = {
        "title": movie_title,
        #"title": "sorcerer",
        "country": country_code,
        "show_type": "movie"
   }

    headers = {
	"x-rapidapi-key": "7f84ac6968msh506e9250e00e425p122fc7jsn8dccfbd2494f",
	"x-rapidapi-host": "streaming-availability.p.rapidapi.com"
    }

    response = requests.get(url, headers=headers, params=querystring)
    print(response.status_code) 
    if response.status_code != 200:
        print("Error fetching data from the API.")
        messagebox.showerror("Could Not Fetch Data", "Response Status Code == {response.status_code}")
    else:
        data = response.json()
        results = data
        if results:
            first_result = results[0]
            title = first_result["title"]
            services = first_result.get("streamingOptions", {}).get(country_code, {})
            print(f"\nðŸŽ¬ Found: {title}")

            if len(services) == 0:
                messagebox.showwarning("Not Found", f"{movie_title} curently not found in {countries_to_try_dictionary[country_code]} streaming options")
            else:

                if auto_find:
                    open_all_movie_links_automatically(services)
                else:
                    open_all_movie_links_manually(title, services)

                keep_checking_countries = False
                    
        else:
           print("No streaming information found for this movie.") 
           messagebox.showwarning("Not Found", f"{movie_title} currently not found in usual streaming options")

def cycle_through_countries_for_movie(movie_title, auto_find):
    global keep_checking_countries
    for country in other_countries_to_try:
        if keep_checking_countries:
            find_possible_streaming_places_function(movie_title, country, auto_find)
        else:
            keep_checking_countries = True
            return
        
    messagebox.showwarning("Not Found", f"{movie_title} currently not found in usual streaming options")

def choose_movie(auto_open):
    global movie_title
    global chosen_line
    chosen_line = random.choice(lines)
    print(f"Movie Selected: {chosen_line}")

    movie_info_line = [part for part in chosen_line.split('\t') if part.strip() != '']
    movie_title = movie_info_line[0]
    movie_year = movie_info_line[1]
    movie_producer = movie_info_line[2]

    movie_selected_title.config(text = movie_title)
    movie_selected_year_made.config(text = movie_year)
    movie_selected_producer.config(text = f"Produced By: {movie_producer}")

    print(movie_title) 
    print(movie_year)
    print(movie_producer)

    top_button_frame.pack(pady=10)
    auto_find_streaming_places_button.pack(side="left", padx=5, pady=5)
    manual_find_streaming_places_button.pack(side="left", padx=5, pady=5)
    bottom_button_frame.pack(pady=10)
    select_and_save_movie_button.pack(side="left", padx=5, pady=5)
    rate_a_watched_movie_button.pack(side="left", padx=5, pady=5)

    return chosen_line

def select_and_save_movie():

    message_box_result = messagebox.askyesno("Save Movie", "This will remove movie from Non Watched List")
    if message_box_result:  
        global chosen_line
        if chosen_line in lines:
             lines.remove(chosen_line)
        else:
            print("Error: Selected movie not found in the list.")

        # Overwrite OscarBestPictureNotWatched.txt to write the list without chosen movie
        with open(not_watched_file, 'w') as file:
            for line in lines:
                file.write(line + '\n')

        # Append the chosen movie to OscarBestPicturesWatched.txt
        with open(watched_file, 'a') as file:
            file.write(chosen_line + '\n')

    else:
        print("Canceled.")

def rate_a_watched_movie():
    with open(watched_file, 'r') as file:
        lines = [line.strip() for line in file if line.strip()]

    popup = tk.Toplevel(root)
    popup.title("Rate a Watched Movie")
    popup.geometry("800x800")

    # --- Create a canvas with a scrollbar ---
    popup_canvas = tk.Canvas(popup)
    scrollbar = tk.Scrollbar(popup, orient="vertical", command=popup_canvas.yview)
    scrollable_frame = tk.Frame(popup_canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: popup_canvas.configure(
            scrollregion=popup_canvas.bbox("all")  # update scroll region to include new widgets
        )
    )

    popup_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    popup_canvas.configure(yscrollcommand=scrollbar.set)

    popup_canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

   #Make the Buttons for each link
    def on_select(line):
        print(line)
        popup = tk.Toplevel(root)
        popup.title(f"Rate {line}")
        popup.geometry("400x300")
        #tk.Label(root, text="Select a number 1â€“5:").pack(pady=10)

        combo = tk.Combobox(popup, values=[1, 2, 3, 4, 5], state="readonly")
        combo.pack(pady=5)
        combo.current(0) 
        #Enter a new popup that will open up and do something, like you can choose stars, or write a review
        #message_box = what do you rate this movie?

    for line in lines:
        button = tk.Button(scrollable_frame, text=line, anchor="w", command=lambda i=line: on_select(i))
        button.pack(fill="x")

def run_movie_selection():
    auto_open = auto_open_var.get()
    choose_movie(auto_open)

def open_popup_window_manual(movie_title, streaming_service_pairs):
    popup = tk.Toplevel(root)
    popup.title("Select a Watched Movie")
    popup.title(f"Movie Title : {movie_title}")
    popup.geometry("800x800")

    popup_canvas = tk.Canvas(popup)
    scrollbar = tk.Scrollbar(popup, orient="vertical", command=popup_canvas.yview)
    scrollable_frame = tk.Frame(popup_canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: popup_canvas.configure(
            scrollregion=popup_canvas.bbox("all")
        )
    )

    popup_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    popup_canvas.configure(yscrollcommand=scrollbar.set)

    popup_canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    def on_select(link):
        webbrowser.open(link)

    for pair in streaming_service_pairs:
        button = tk.Button(scrollable_frame, text=pair[0], anchor="w", command=lambda link=pair[1]: on_select(link))
        button.pack(fill="x")

def open_popup_window(file_to_open):
    with open(file_to_open, 'r') as file:
        lines = [line.strip() for line in file if line.strip()]

    popup = tk.Toplevel(root)
    popup.title("Select a Watched Movie")
    popup.geometry("800x800")

    # --- Create a canvas with a scrollbar ---
    popup_canvas = tk.Canvas(popup)
    scrollbar = tk.Scrollbar(popup, orient="vertical", command=popup_canvas.yview)
    scrollable_frame = tk.Frame(popup_canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: popup_canvas.configure(
            scrollregion=popup_canvas.bbox("all")  # update scroll region to include new widgets
        )
    )

    popup_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    popup_canvas.configure(yscrollcommand=scrollbar.set)

    popup_canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

   #Make the Buttons for each link
    def on_select(line):
        manual_select_movie_info_line = [part for part in line.split('\t') if part.strip() != '']
        manual_select_movie_title = manual_select_movie_info_line[0]
        cycle_through_countries_for_movie(manual_select_movie_title)

    for line in lines:
        button = tk.Button(scrollable_frame, text=line, anchor="w", command=lambda i=line: on_select(i))
        button.pack(fill="x")

def reset_watched_list():
    message_box_result = messagebox.askyesno("Reset Watched List", "Selecting 'YES' will erase all movies in Watched List?")
    if message_box_result:
         with open(watched_file, 'w') as file:
            pass
            print("Resetting Watched List File")

def reset_unwatched_list():
    message_box_result = messagebox.askyesno("Reset UnWatched List", "Selecting 'YES' will put all movies back in UnWatched List?")
    if message_box_result:
        with open(nominations_full_list_file, 'r') as full_file:
            lines = [line.strip() for line in full_file if line.strip()] 
            with open(not_watched_file, 'w') as updated_file:
                for line in lines:
                    updated_file.write(line + '\n')

def debug_fix_corrupted_lists():
    message_box_result = messagebox.askyesno("Fix Corrupted Watched and UnWatched Lists", "Selecting 'YES' will update Unwatched list to not count movies in watched list")
    if message_box_result:
        with open(nominations_full_list_file, 'r') as full_nominations_file:
            nominations_lines = [line.strip() for line in full_nominations_file if line.strip()] 
            with open(watched_file, 'r') as full_watched_file:
                watched_lines = [line.strip() for line in full_watched_file if line.strip()] 
                with open(not_watched_file, 'w') as full_unwatched_file:
                    for nomination_line in nominations_lines:
                        if nomination_line not in watched_lines:
                            full_unwatched_file.write(nomination_line + '\n')

def exit_app():
    root.quit()

with open(not_watched_file, 'r') as file:
    lines = [line.strip() for line in file if line.strip()] 

if not lines:
    print("The source file is empty.")
else:

    background_color="#88ccf3"

    root = tk.Tk()
    root.title("Oscar Best Picture Nominated Selector")
    window_width = 1500
    window_height = 800
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()
    x = int((screen_width / 2) - (window_width / 2))
    y = int((screen_height / 2) - (window_height / 2) - 50)
    root.geometry(f"{window_width}x{window_height}+{x}+{y}")
    root.configure(bg=background_color)

    # Create the main menu bar
    menu_bar = tk.Menu(root)
    root.config(menu=menu_bar)

    # ----- File Menu -----
    file_menu = tk.Menu(menu_bar, tearoff=0)  # "tearoff=0" removes the dashed line
    file_menu.add_command(label= "See Watched List", command= lambda:open_popup_window(watched_file))
    file_menu.add_command(label= "See UnWatched List", command= lambda:open_popup_window(not_watched_file))
    file_menu.add_separator()
    file_menu.add_command(label="Reset Watched List", command=reset_watched_list)
    file_menu.add_command(label="Reset UnWatched List", command=reset_unwatched_list)
    file_menu.add_separator()
    file_menu.add_command(label="Debug Fix Corrupted Lists", command=debug_fix_corrupted_lists)
    menu_bar.add_cascade(label="File", menu=file_menu)

    exit_menu = tk.Menu(menu_bar)
    exit_menu.add_command(label="Exit", command=exit_app)
    menu_bar.add_cascade(label="Exit", menu=exit_menu)


    tk.Label(
        root, 
        text="Randomly Find Best Picture Nominated Movie",
        bg=background_color,
        font=("Arial", 20, "bold") 
        ).pack(pady=10)
    
    auto_open_var = tk.BooleanVar()

    button = tk.Button(
        root,
        text="Choose Movie",
        command=run_movie_selection,
        font=("Arial", 20, "bold"),
        width=20,     # number of characters wide
        height=2,     # number of text lines tall
        padx=10,      # internal padding (horizontal)
        pady=10       # internal padding (vertical)
    )
    button.pack(pady=10)

    movie_selected_title = tk.Label(
        root,
        text="Movie Selected : ",
        bg=background_color,
        font=("Arial", 20, "bold"),
        width=100,     
        height=2,     
        padx=10,      
        pady=5 
    )
    movie_selected_title.pack(pady=5)

    movie_selected_year_made = tk.Label(
        root,
        text="Year Made : ",
        bg=background_color,
        font=("Arial", 20, "bold"),
        width=100,     
        height=2,     
        padx=10,      
        pady=5       
    )
    movie_selected_year_made.pack(pady=5)

    movie_selected_producer = tk.Label(
        root,
        text="Produced By : ",
        bg=background_color,
        font=("Arial", 20, "bold"),
        width=100,     
        height=2,     
        padx=10,      
        pady=5    
    )
    movie_selected_producer.pack(pady=5)

    top_button_frame = tk.Frame(root, bg=background_color)
    top_button_frame.pack_forget()

    auto_find_streaming_places_button = tk.Button(
        top_button_frame,
        text="Auto Find Streaming Places",
        command = lambda: cycle_through_countries_for_movie(movie_title, True),
        font=("Arial", 20, "bold"),
        width=30,     
        height=2,     
        padx=10,      
        pady=10      
    )
    auto_find_streaming_places_button.pack_forget()

    manual_find_streaming_places_button = tk.Button(
        top_button_frame,
        text="Manual Find Streaming Places",
        command = lambda: cycle_through_countries_for_movie(movie_title, False),
        font=("Arial", 20, "bold"),
        width=30,     
        height=2,     
        padx=10,      
        pady=10      
    )
    manual_find_streaming_places_button.pack_forget()

    bottom_button_frame = tk.Frame(root, bg=background_color)
    bottom_button_frame.pack_forget()

    select_and_save_movie_button = tk.Button(
        bottom_button_frame,
        text="Choose and Save Movie",
        command = lambda: select_and_save_movie(),
        bg="#03c94f",
        font=("Arial", 20, "bold"),
        width=30,     
        height=2,     
        padx=10,      
        pady=10      
    )
    select_and_save_movie_button.pack_forget()

    rate_a_watched_movie_button = tk.Button(
        bottom_button_frame,
        text="Rate a Watched Movie",
        command = lambda: rate_a_watched_movie(),
        font=("Arial", 20, "bold"),
        width=30,     
        height=2,     
        padx=10,      
        pady=10 
    )
    rate_a_watched_movie_button.pack_forget()

    root.mainloop()